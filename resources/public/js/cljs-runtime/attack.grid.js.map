{"version":3,"sources":["attack/grid.cljs"],"mappings":"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","names":["attack.grid/empty-grid","cols","attack.grid/replace-blocks","grid","replacement-blocks","cljs.core.assoc","cljs.core.into","attack.grid/block-points","block","attack.block/garbage?","attack.block/garbage-block-points","attack.block/swap?","attack.block/disappear?","cljs.core.reduce","cljs.core/concat","cljs.core.map","attack.block/swap-empty?","cljs.core/cons","G__34130","attack.block/dissolve?","cljs.core/contains?","p__34133","map__34134","cljs.core/--destructure-map","cljs.core.get","attack.grid/hash-blocks","blocks-hash","blocks","new-hash","mem","blk","in-mem","pos","p__34135","map__34136","attack.grid/unhash-blocks","h","positions","new-h","cljs.core.dissoc","p__34137","map__34138","attack.grid/add-blocks","new-blocks","cljs.core.concat","p__34139","map__34140","attack.grid/remove-blocks","blks-to-remove","cljs.core.remove","attack.grid/remove-and-add-blocks","blocks-to-remove","blocks-to-add","p__34141","map__34142","attack.grid/all-simple-blocks","cljs.core.filter","attack.block/simple?","cljs.core/flatten","p__34144","map__34145","attack.grid/simple-blocks-match?","old","new","p1__34147#","blk-set","old-set","new-set","cljs.core._EQ_","p__34151","map__34152","attack.grid/garbage-blocks","attack.grid/garbage-block-points","all","attack.grid/garbage-block-points-set","p__34154","map__34155","attack.grid/swap-empty-points","p1__34153#","attack.grid/swap-empty-points-set","attack.grid/simple-block-points","p1__34156#","attack.grid/simple-block-points-set","p__34157","map__34158","attack.grid/all-occupied-pts-without-falling","p__34159","map__34160","attack.grid/all-occupied-pts","p__34161","map__34162","map__34163","fall-pos","attack.block/falling?","attack.grid/all-occupied-pts-without-falling-set","clojure.set.union","p__34165","map__34166","attack.grid/cache-occupied-blocks!","clock","fn-raw","fn-cache","fn-clock","cljs.core.not_EQ_","attack.grid/cached-occupied-blocks","gr","attack.grid/occupied-at-without-falling?","point","attack.grid/occupied-at?","attack.grid/line-count","cljs.core/count","cljs.core.distinct","p__34171","vec__34172","cljs.core.nth","_","y","p__34175","map__34176","attack.grid/swap-empty","replace-block","new-pos","new-block","attack.block/new-swap-empty","p__34177","map__34178","attack.grid/swap-blocks","a","b","cljs.core/every?","swap-blk","attack.block/new-swap","p__34179","map__34180","attack.grid/block-at","p__34182","map__34185","attack.grid/add-row","rows","new-last","x","attack.block/new-simple","attack.point/point","attack.block/rand-type","cljs.core.range","attack.grid/default","fns","cljs.core.repeat","g","func","p__34192","map__34193","attack.grid/block-in-direction","dir","attack.point/point-add","attack.grid/matches-in-direction-matching-block-with-quota","next-blk","recurse?","attack.block/same-type?","attack.grid/find-matches-with-grid-block-in-directions","dirs","p1__34210#","fn-match-dir","matches","length-matches","p1__34213#","flat-matches","attack.grid/find-matches-with-grid-block","p1__34214#","fn-find","horizontal","attack.point/horizontal","vertical","attack.point/vertical","cljs.core.comp","cljs.core/not","cljs.core/empty?","attack.grid/is-not-equal-subset?","set1","set2","clojure.set/subset?","attack.grid/isnt-subset-of-another?","large-set","cljs.core.partial","attack.grid/condense-match-set","match-set","condensed","mset","attack.grid/to-superset","orig-set","coll","result","cljs.core/first","xs","cljs.core/rest","p1__34219#","cljs.core/some","attack.grid/condense-match-set2","p__34223","map__34224","attack.grid/disappear-blocks","grid-blocks","blocks-to-disappear","attack.block/new-disappear","attack.grid/reduce-matches","p__34227","map__34228","attack.grid/match-sets","all-blocks","simple-blocks","set-vectors","non-nil-set-vectors","cljs.core/nil?","sets","p1__34226#","filtered-sets","attack.grid/disappear-blocks-from-match-set","cljs.core/into","p__34231","map__34232","attack.grid/remove-blocks-with-pred","pred","p__34235","p__34236","map__34238","vec__34239","attack.grid/position-valid","attack.grid/should-position-fall?","pt-below","attack.point/below","p__34266","map__34267","vec__34268","attack.grid/garbage-block-bottom-points","ox","oy","height","length","garbage-block","p1__34264#","attack.grid/should-garbage-block-fall?","bottom-points","p1__34272#","p__34274","map__34275","attack.grid/should-simple-block-fall?","attack.grid/should-block-fall?","p__34279","map__34280","attack.grid/create-falling-blocks","falling-blocks","attack.grid/fallers","attack.block/new-falling","p__34282","map__34283","attack.grid/resolve-swap-empty-blocks","to-resolve","attack.block/should-resolve-swap-empty?","attack.block/resolve-swap-empty","p__34285","map__34286","attack.grid/resolve-falling-blocks","attack.block/should-resolve-falling?","attack.block/resolve-falling","attack.grid/resolve-disappear-blocks","p1__34287#","attack.tick/ticks0?","p__34289","map__34290","attack.grid/resolve-swaps","attack.block/should-resolve-swap?","to-add","p1__34288#","attack.block/blocks-swap!","p__34302","map__34303","attack.grid/step-blocks","have-ticks","p1__34295#","ticked","attack.tick/dec-ticks","p__34306","map__34307","attack.grid/resolve-dissolve-blocks","dissolves","ready","new-grid","attack.block/resolve-dissolve","attack.grid/dissolve-blocks-from-garbage-blocks","attack.block/new-dissolve","p__34310","map__34311","vec__34312","attack.grid/garbage-block-boundary-points","x-min","x-max","y-max","y-min","top-and-bottom","iter__5480__auto__","s__34316","cljs.core/LazySeq","temp__5825__auto__","cljs.core/seq","xs__6385__auto__","iterys__5476__auto__","s__34318","cljs.core/chunked-seq?","c__5478__auto__","size__5479__auto__","b__34320","cljs.core/chunk-buffer","i__34319","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__34317","cljs.core/chunk-rest","fs__5477__auto__","iter__34315","left-and-right","s__34325","s__34327","b__34329","i__34328","iter__34326","iter__34324","attack.grid/matchset-points","res","m-set","p1__34334#","p__34343","map__34344","attack.grid/garbage-blocks-adjacent-to-matches","matchset-pts","garbage-blocks","p1__34341#","clojure.set.intersection","attack.grid/resolve-garbage-blocks-with-match-sets","dissolve-blocks","attack.grid/resolve-matches","should-resolve-matches?","attack.grid/resolve-grid","attack.grid/block-can-fall?","attack.grid/blocks-that-can-fall","attack.grid/grid-bottom-row-index-blocks","attack.grid/grid-block-bottom-y","map__34347","vec__34348","map__34351","vec__34352","attack.grid/grid-bottom-row-index","cljs.core.apply","cljs.core/max","attack.grid/fallers-in-bottom-row?","bottom-index","attack.grid/fallers-block-below","pts-fun","p1__34355#","cljs.core/PersistentVector","G__34356","G__34357","attack.grid/fall-map-recur","cljs.core/memoize","attack.grid/make-is-falling2","attack.grid/make-is-falling","G__34366","G__34367","G__34368","cljs.core/deref","attack.grid/with-local-vars","attack.grid/fall-map","blocks-below","attack.grid/fallers-falling-map-all","f","p1__34384#","p2__34385#","fallers-map","fs","s__34388","b__34390","i__34389","vec__34391","iter__34387","vec__34394","value","cljs.core/chunk-first"],"sourcesContent":["; DO NOT EDIT THIS FILE! IT WAS AUTOMATICALLY GENERATED BY\n; lein-cljsbuild FROM THE FOLLOWING SOURCE FILE:\n; file:/Users/jamiely/code/tetris-attack-clojure/src/clj/attack/grid.clj\n\n(ns attack.grid\n  (:require [attack.block :as blk]\n            [attack.point :as pt]\n            [attack.tick :as tick]\n            [attack.compat :as compat])\n  (:use [clojure.set :only [union subset? intersection]]))\n\n(declare fallers)\n\n(defn empty-grid [cols]\n  \"Returns an empty grid\"\n  {:blocks []\n   :rows 0\n   :cols cols\n   :blocks-hash {}})\n\n(defn replace-blocks [grid replacement-blocks]\n  (assoc grid :blocks (into [] replacement-blocks)))\n\n(defn block-points [block]\n  \"Returns all of the points that a block occupies. This is mostly relevant for multi-cell blocks such as garbage blocks\"\n  (cond (blk/garbage? block) (blk/garbage-block-points block)\n        (or (blk/swap? block)\n            (blk/disappear? block)) (reduce concat (map block-points (:blocks block)))\n        (blk/swap-empty? block) (cons (:into-position block)\n                                      (block-points (:block block)))\n        (blk/dissolve? block) (reduce concat (map block-points (:pending-blocks block)))\n        (contains? block :position) [(:position block)]\n        :else []))\n\n(defn hash-blocks [{blocks-hash :blocks-hash :as grid} blocks]\n  (let [new-hash (reduce (fn [mem blk]\n                           (reduce (fn [in-mem pos]\n                                     (assoc in-mem pos blk))\n                                   mem\n                                   (block-points blk)))\n                      blocks-hash\n                      blocks)]\n    (assoc grid :blocks-hash new-hash)))\n\n(defn unhash-blocks [{h :blocks-hash :as grid} blocks]\n    (let [positions (reduce concat (map block-points blocks))\n          new-h (reduce (fn [mem pos]\n                          (dissoc mem pos)) h positions)]\n    (assoc grid :blocks-hash new-h)))\n\n(defn add-blocks [{blocks :blocks :as grid} new-blocks]\n  \"Adds a set of blocks to the grid\"\n  (-> grid\n      (replace-blocks (concat blocks new-blocks))\n      (hash-blocks new-blocks)))\n\n(defn remove-blocks [{blocks :blocks :as grid} blks-to-remove]\n  \"Remove blocks must be a set of blocks to remove from the grid\"\n  (-> grid\n      (replace-blocks (remove blks-to-remove blocks))\n      (unhash-blocks blks-to-remove)))\n\n(defn remove-and-add-blocks [grid blocks-to-remove blocks-to-add]\n  (-> grid\n      (remove-blocks blocks-to-remove)\n      (add-blocks blocks-to-add)))\n\n(defn all-simple-blocks [{blocks :blocks}]\n  (concat (filter blk/simple? blocks)\n          (flatten (map (fn [{blocks :blocks}]\n                          (if (nil? blocks)\n                            []\n                            blocks))\n                        blocks))))\n\n(defn simple-blocks-match? [old new]\n  (let [blk-set #(into #{} (all-simple-blocks %))\n        old-set old\n        new-set new]\n    (= old-set new-set)))\n\n(defn garbage-blocks [{blocks :blocks :as grid}]\n  (filter blk/garbage? blocks))\n\n(defn garbage-block-points [grid]\n  (reduce (fn [all blk]\n            (concat all (blk/garbage-block-points blk)))\n          []\n          (garbage-blocks grid)))\n\n(defn garbage-block-points-set [grid]\n  (into #{} (garbage-block-points grid)))\n\n(defn swap-empty-points [{blocks :blocks :as grid}]\n  (map #(:into-position %)\n       (filter blk/swap-empty? blocks)))\n\n(defn swap-empty-points-set [grid]\n  (into #{} (swap-empty-points grid)))\n\n(defn simple-block-points [grid]\n  (map #(:position %) (all-simple-blocks grid)))\n\n(defn simple-block-points-set [grid]\n  (into #{} (simple-block-points grid)))\n\n(defn all-occupied-pts-without-falling [{blocks :blocks :as grid}]\n  (concat (simple-block-points grid)\n          (swap-empty-points grid)\n          (garbage-block-points grid)))\n\n(defn all-occupied-pts [{blocks :blocks :as grid}]\n  (concat (all-occupied-pts-without-falling grid)\n          (reduce (fn [mem {{pos :position} :block fall-pos :falling-to}]\n                    (concat mem [pos fall-pos]))\n                  []\n                  (filter blk/falling? blocks))))\n\n(defn all-occupied-pts-without-falling-set [grid]\n  (union (simple-block-points-set grid)\n         (swap-empty-points-set grid)\n         (garbage-block-points-set grid)))\n\n(defn cache-occupied-blocks! [{clock :cache-clock :as grid}]\n  (let [fn-raw #(all-occupied-pts-without-falling-set grid)\n        ; @todo there is a potential bug here if the game has not passed a clock value in\n        fn-cache (fn [] (assoc grid :cache-occupied {:clock clock\n                                                     :occupied (fn-raw)}))\n        fn-clock (fn [] (:clock (:cache-occupied grid)))]\n        (if (or (nil? clock) ; the game has not annotated the grid with the clock tick\n                (nil? (:cache-occupied grid)) ; no cache data available\n                (not= clock (fn-clock))) ; the clock tick is equal\n          (fn-cache)\n          grid)))\n\n(defn cached-occupied-blocks [grid]\n  \"Returns the cached occupied blocks associated with the current grid.\"\n  (let [gr (cache-occupied-blocks! grid)]\n    (:occupied (:cache-occupied gr))))\n\n(defn occupied-at-without-falling? [grid point]\n  (contains? (cached-occupied-blocks grid)\n             point))\n\n(defn occupied-at? [grid point]\n  (contains? (into #{} (all-occupied-pts grid))\n             point))\n\n(defn line-count [grid]\n  (count (distinct (map (fn [[_ y]] y)\n                        (all-occupied-pts grid)))))\n\n(defn swap-empty [{blocks :blocks :as grid} replace-block new-pos]\n  \"Creates a new swap-empty block using the passed block\"\n  (if (occupied-at? grid new-pos)\n    grid\n    (let [new-block (blk/new-swap-empty replace-block new-pos)]\n      (remove-and-add-blocks grid\n                             #{replace-block}\n                             #{new-block}))))\n\n(defn swap-blocks [{blocks :blocks :as grid} a b]\n  \"Replaces the passed blocks in the grid with a swap block\"\n  (if (every? blk/simple? [a b])\n    (let [swap-blk (blk/new-swap a b)]\n      (remove-and-add-blocks grid #{a b} #{swap-blk}))\n    grid))\n\n(defn block-at [{h :blocks-hash} point]\n  (get h point))\n\n(defn add-row [{blocks :blocks\n                rows :rows\n                cols :cols\n                :as grid}]\n  (let [new-last (+ rows 1)\n        new-block (fn [x]\n                    (blk/new-simple (pt/point x new-last) (blk/rand-type)))\n        new-blocks (map new-block (range 1 (+ cols 1)))]\n    (-> grid\n        (add-blocks new-blocks)\n        (assoc :rows new-last))))\n\n(defn default [cols rows]\n  (let [grid (empty-grid cols)\n        fns (repeat rows add-row)]\n    (reduce (fn [g func] (func g)) grid fns)))\n\n(defn block-in-direction [grid {pos :position} dir]\n  (block-at grid (pt/point-add pos dir)))\n\n(defn matches-in-direction-matching-block-with-quota [grid dir blk]\n  (let [next-blk (block-in-direction grid blk dir)\n        recurse? (and (not (nil? next-blk)) (blk/same-type? blk next-blk))]\n    (if recurse?\n      (cons blk (matches-in-direction-matching-block-with-quota grid dir next-blk))\n      [blk])))\n\n(defn find-matches-with-grid-block-in-directions [grid blk dirs]\n  \"Returns all the matches in the grid using the block as the origin\"\n  (let [fn-match-dir #(matches-in-direction-matching-block-with-quota grid % blk)\n        matches (map fn-match-dir dirs)\n        length-matches (filter #(<= 3 (count %)) matches)\n        flat-matches (flatten length-matches)]\n    flat-matches))\n\n(defn find-matches-with-grid-block [grid blk]\n  \"Returns all the matches in the grid using the block as the origin\"\n  (let [fn-find #(find-matches-with-grid-block-in-directions grid blk %)\n        horizontal (fn-find (pt/horizontal))\n        vertical (fn-find (pt/vertical))\n        matches [horizontal vertical]]\n    (flatten (filter (comp not empty?) matches))))\n\n(defn is-not-equal-subset? [set1 set2]\n  (and (subset? set1 set2) (not= set1 set2)))\n\n(defn isnt-subset-of-another? [set1 large-set]\n  (empty? (filter (partial is-not-equal-subset? set1)\n                  large-set)))\n\n(defn condense-match-set [match-set]\n  (reduce (fn [condensed mset]\n            (if (isnt-subset-of-another? mset match-set)\n              (cons condensed mset)\n              condensed)) match-set))\n\n(defn to-superset [ orig-set ]\n  \"http://stackoverflow.com/questions/8162149/remove-all-the-subsets-in-a-list-of-sets\"\n  (let [coll (into '() orig-set)]\n    (loop [result () coll coll]\n      (if (empty? coll) result\n          (let  [x  (first coll)\n                 xs (rest coll)]\n            (if (some #(clojure.set/subset? x %) xs) \n              (recur result xs)\n              (recur (cons x result) xs)))))))\n\n(defn condense-match-set2 [ match-set ]\n  (into #{} (to-superset match-set)))\n\n(defn disappear-blocks [{grid-blocks :blocks :as grid} blocks-to-disappear]\n  \"Creates a disappear-type block using the passed blocks and inserts it into a new grid\"\n  (if (empty? blocks-to-disappear)\n    grid\n    (remove-and-add-blocks grid\n                           (into #{} blocks-to-disappear)\n                           #{(blk/new-disappear blocks-to-disappear)})))\n\n(defn reduce-matches [grid matches block]\n  (cons (find-matches-with-grid-block grid block)\n        matches))\n\n(defn match-sets [{all-blocks :blocks :as grid}]\n  \"Returns a sequence (probably a set) of match sets. Only simple blocks may be matched\"\n  (let [simple-blocks (filter blk/simple? all-blocks)\n        set-vectors (reduce (partial reduce-matches grid) [] simple-blocks)\n        non-nil-set-vectors (filter (comp not nil?) set-vectors)\n        sets (map #(into #{} %) non-nil-set-vectors)\n        filtered-sets (filter (comp not empty?) sets)]\n    (condense-match-set2 (into #{} filtered-sets))))\n\n(defn disappear-blocks-from-match-set [grid match-set]\n  (disappear-blocks grid (flatten (map (partial into '())\n                                       match-set))))\n\n\n(defn remove-blocks-with-pred [{blocks :blocks :as grid} pred]\n  \"Removes blocks from the passed grid filtered using the passed predicate\"\n  (remove-blocks grid (into #{} (filter pred blocks))))\n\n(defn position-valid [{rows :rows cols :cols :as grid} [x y]]\n  \"Determines whether the passed position is valid relative to the grid\"\n  (and (< 0 x)\n       (< 0 y)\n       (>= rows y)\n       (>= cols x)))\n\n(defn should-position-fall? [grid pos]\n  (let [pt-below (pt/below pos)]\n    (if (position-valid grid pt-below)\n      (if (occupied-at-without-falling? grid pt-below)\n        false\n        true)\n      false)))\n\n(defn garbage-block-bottom-points [{[ox oy] :position\n                                    height :height\n                                    length :length :as garbage-block}]\n  (if (blk/garbage? garbage-block)\n    (map #(pt/point (+ ox %) oy)\n         (range 0 length))\n    []))\n\n(defn should-garbage-block-fall? [grid garbage-block]\n  \"Determines whether or not a garbage block should fall\"\n  (if (blk/garbage? garbage-block)\n    (let [bottom-points (garbage-block-bottom-points garbage-block)]\n      (every? #(true? (should-position-fall? grid %))\n              bottom-points))\n    false))\n\n(defn should-simple-block-fall? [grid {pos :position :as block}]\n  \"Determines whether the passed block should be falling, and if so, returns a falling block\"\n  (if (or (nil? pos) (not (blk/simple? block)))\n    false\n    (should-position-fall? grid pos)))\n\n(defn should-block-fall? [grid block]\n  \"Determines whether the passed block should be falling, and if so, returns a falling block\"\n  (or (should-simple-block-fall? grid block)\n      (should-garbage-block-fall? grid block)))\n\n(defn create-falling-blocks [{blocks :blocks :as grid}]\n  \"Figures out whether a block in the grid should be falling, and if so, converts it into a falling block\"\n  (let [falling-blocks (into #{} (fallers grid))]\n    (remove-and-add-blocks grid\n                           falling-blocks\n                           (map blk/new-falling falling-blocks))))\n\n(defn resolve-swap-empty-blocks [{blocks :blocks :as grid}]\n  (let [to-resolve (into #{} (filter blk/should-resolve-swap-empty? blocks))]\n    (remove-and-add-blocks grid\n                           (into #{} to-resolve)\n                           (map blk/resolve-swap-empty to-resolve))))\n\n(defn resolve-falling-blocks [{blocks :blocks :as grid}]\n  \"Changes blocks which have finished falling in the grid into regular blocks\"\n  (let [to-resolve (into #{} (filter blk/should-resolve-falling? blocks))]\n    (remove-and-add-blocks grid\n                           (into #{} to-resolve)\n                           (map blk/resolve-falling to-resolve))))\n\n(defn resolve-disappear-blocks [grid]\n  (remove-blocks-with-pred grid #(and (blk/disappear? %)\n                                       (tick/ticks0? %))))\n\n(defn resolve-swaps [{blocks :blocks :as grid}]\n  \"Dissolves swap blocks when the ticks reach 0\"\n  (let [to-resolve (filter blk/should-resolve-swap? blocks)\n        to-add (flatten (map #(blk/blocks-swap! (:blocks %))\n                             to-resolve))]\n    (remove-and-add-blocks grid\n                           (into #{} to-resolve)\n                           to-add)))\n\n(defn step-blocks [{blocks :blocks :as grid}]\n  \"Resolves ticks for each block\"\n  (let [have-ticks (filter #(contains? % :ticks) blocks)\n        ticked (map tick/dec-ticks have-ticks)]\n    (remove-and-add-blocks grid\n                           (into #{} have-ticks)\n                           ticked)))\n\n(defn resolve-dissolve-blocks [{blocks :blocks :as grid}]\n  \"Handles resolution of dissolve blocks\"\n  (let [dissolves (filter blk/dissolve? blocks)\n        ready (filter tick/ticks0? dissolves)\n        new-grid (reduce (fn [g blk]\n                           (remove-and-add-blocks g\n                                                  #{blk}\n                                                  (blk/resolve-dissolve blk)))\n                         grid\n                         ready)]\n    new-grid))\n\n(defn dissolve-blocks-from-garbage-blocks [grid blocks]\n  \"Turns the passed garbage blocks into 'dissolve' blocks, which transition\n   a garbage block into a bunch of simple blocks\"\n\n  (into #{} (map blk/new-dissolve\n                 (filter blk/garbage? blocks))))\n\n(defn garbage-block-boundary-points [grid {[ox oy] :position\n                                           height :height\n                                           length :length :as block}]\n  \"Returns the points that border the garbage block\"\n  (let [x-min (- ox 1)\n        x-max (+ ox length)\n        y-max (+ oy 1)\n        y-min (- oy height)\n        top-and-bottom (for [x (range ox x-max)\n                             y [y-min y-max]]\n                         (pt/point x y))\n        left-and-right (for [x [x-min x-max]\n                             y (range oy y-max 1)]\n                         (pt/point x y))]\n    (into #{} (filter (partial position-valid grid)\n                      (concat top-and-bottom\n                              left-and-right)))))\n                          \n\n(defn matchset-points [matches]\n  \"Returns the points associated with all of the points of the match set\"\n  (into #{} (reduce (fn [res m-set]\n                      (concat res (map #(:position %) m-set)))\n                    []\n                    matches)))\n\n(defn garbage-blocks-adjacent-to-matches [{blocks :blocks :as grid}\n                                          matches]\n  \"Given a grid and a set of matches, determines the garbage blocks which are adjacent to any of the blocks\"\n  (let [matchset-pts (matchset-points matches)\n        garbage-blocks (filter blk/garbage? blocks)]\n    (into #{} (filter #((comp not empty?) (intersection (garbage-block-boundary-points grid %)\n                                                        matchset-pts))\n                      garbage-blocks))))\n\n(defn resolve-garbage-blocks-with-match-sets [grid matches]\n  \"Handles resolution of garbage blocks relative to any match sets\"\n  (let [garbage-blocks (garbage-blocks-adjacent-to-matches grid matches)\n        dissolve-blocks (dissolve-blocks-from-garbage-blocks grid garbage-blocks)]\n  (remove-and-add-blocks grid garbage-blocks dissolve-blocks)))\n\n(defn resolve-matches [should-resolve-matches? grid]\n  (if should-resolve-matches? \n    (let [matches (match-sets grid)]\n      (-> grid\n          (disappear-blocks-from-match-set matches)\n          resolve-disappear-blocks\n          (resolve-garbage-blocks-with-match-sets matches)))\n    grid))\n\n(defn resolve-grid [grid should-resolve-matches?]\n  (->> grid\n       step-blocks\n       resolve-swaps\n       create-falling-blocks\n       (resolve-matches should-resolve-matches?)\n       resolve-dissolve-blocks\n       ;; create falling blocks BEFORE resolving existing once\n       ;; so that we provide an opportunity for the player to\n       ;; swap out a block that has temporarily finished falling\n       ;; (1-space)\n       resolve-falling-blocks\n       resolve-swap-empty-blocks))\n\n(defn block-can-fall? [block]\n  (or (blk/simple? block)\n      (blk/garbage? block)))\n\n(defn blocks-that-can-fall [grid]\n  (filter block-can-fall? (:blocks grid)))\n\n(def grid-bottom-row-index-blocks blocks-that-can-fall)\n\n(defn grid-block-bottom-y [block]\n  (cond (blk/garbage? block) (let [{[x y] :position height :height} block]\n                               (- (+ y height) 1))\n        (blk/simple? block) (let [{[x y] :position} block] y)\n        :else nil))\n\n(defn grid-bottom-row-index [grid]\n  \"Returns the index of the bottom-most block in the grid\"\n  (->> grid\n       grid-bottom-row-index-blocks\n       (map grid-block-bottom-y)\n       (remove nil?)\n       (apply max)))\n\n(defn fallers-in-bottom-row? [bottom-index block]\n  \"Accepts a function that returns the bottom row of the grid, and a block to test.\"\n  (let [y (grid-block-bottom-y block)]\n    (if (nil? y)\n      false\n      (= y bottom-index))))\n\n(defn fallers-block-below [grid block]\n  \"Returns the blocks below the passed block\"\n  (let [pts-fun (cond (blk/simple? block) #(vector (:position %))\n                      (blk/garbage? block) garbage-block-bottom-points\n                      (blk/swap? block) (fn [blk]\n                                          (reduce concat\n                                                  (map (partial fallers-block-below grid)\n                                                       (:blocks blk))))\n                      (blk/swap-empty? block) (fn [blk]\n                                                (cons (:into-position blk)\n                                                      (fallers-block-below grid (:block blk))))\n                      :else (fn [_] []))]\n        (remove nil? (map (comp (partial block-at grid) pt/below)\n                          (pts-fun block)))))\n\n(def fall-map-recur\n  \"Returns a memoized recursive function that takes a block and determines if it is falling.\"\n  (memoize (fn [grid bottom-index block]\n             (cond (nil? block) false\n                   (false? (block-can-fall? block)) false\n                   (fallers-in-bottom-row? bottom-index block) false\n                   :else (every? (partial fall-map-recur grid bottom-index)\n                                 (fallers-block-below grid block))))))\n\n(defn make-is-falling2 [grid]\n  (let [bottom-index (grid-bottom-row-index grid)]\n    (partial fall-map-recur grid bottom-index)))\n\n(defn make-is-falling [grid]\n  \"Returns a memoized recursive function that takes a block and determines if it is falling.\"\n  (let [bottom-index (grid-bottom-row-index grid)]\n    (with-local-vars\n        [fall-map (memoize (fn [block]\n                             (cond (nil? block) false\n                                   (false? (block-can-fall? block)) false\n                                   (fallers-in-bottom-row? bottom-index block) false\n                                   :else (let [blocks-below (fallers-block-below grid block)]\n                                           (if (empty? blocks-below)\n                                             true\n                                             (every? fall-map blocks-below))))))]\n      (.bindRoot fall-map @fall-map)\n      @fall-map)))\n\n(defn fallers-falling-map-all [grid]\n  \"Returns a map showing each block and its fall status\"\n  (let [f (make-is-falling2 grid)\n        blocks (blocks-that-can-fall grid)]\n    (reduce #(assoc %1 %2 (f %2)) {} blocks)))\n\n(defn fallers [grid]\n  \"Returns blocks that are falling. Only works with simple blocks\"\n  (let [fallers-map (fallers-falling-map-all grid)\n        fs (for [[block value] fallers-map\n                 :when (true? value)]\n             block)]\n    ;; (compat/log \"fallers!!\")\n    ;; (compat/log fs)\n    ;; (when-not (empty? fs)\n    ;;   (compat/log \"map!!\")\n    ;;   (compat/log fallers-map))\n    fs))\n      \n  "]}